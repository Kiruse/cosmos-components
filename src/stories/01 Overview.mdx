import '..';
import { modals } from '..';
import { getNetworks } from '../internals';

# Overview
Kiru's Cosmos Components are a collection of web components that I use to build
my Web3 Dapps for the Cosmos blockchain ecosystem. These components are designed
to be used to jumpstart the creation of new Dapps with as little effort as possible.

However, it is still an early work in progress, and only few components have
been implemented. This page serves as a quick overview of the available components.

# Setup
These components are designed to be used both with a package manager as well
as a CDN.

## Package Manager
Install with your favorite package manager's equivalent of:

```bash
npm install @kiruse/cosmos-components
```

Then, import in your project:

```ts
import { CosmosComponents } from '@kiruse/cosmos-components';
CosmosComponents.register();
```

## CDN
Include the following script in your HTML:

```html
<script type="module">
  import { CosmosComponents } from 'https://esm.sh/@kiruse/cosmos-components';
  CosmosComponents.register();
</script>
```

You may also use an import map to make imports consistent:

```html
<script type="importmap">
  { "imports": { "@kiruse/cosmos-components": "https://esm.sh/@kiruse/cosmos-components" } }
</script>
<script type="module">
  import { CosmosComponents } from '@kiruse/cosmos-components';
  CosmosComponents.register();
</script>
```

# Components

## Connect Boundary
The `cosmos-connect-boundary` component switches between three different
states based on whether the user has connected their wallet and/or signed in.
Signing in is particularly useful for Dapps that communicate with a backend
server, but is optional and defaults to false.

It is a flow control component that provides no other UI and is completely
unstyled. It is meant to be used together with your own UI components.

It uses three slots to display your content. None of these slots provide default
content.

- `content`: Shown when the user has connected their wallet and signed in
  (if required).
- `connect`: Shown when the user has not yet connected their wallet.
- `login`: Shown when the user has connected their wallet but still needs to
  sign in.

The login step is often not needed. Thus, if the `is-logged-in` attribute is
not present or nullish, the `login` slot is never shown. Accordingly, if the
`is-logged-in` attribute is false, the `connect` slot is shown after the user
has connected their wallet. Otherwise, the `content` slot is shown.

<cosmos-connect-boundary persist="true">
  <div slot="content">
    <pre>Thank you for connecting your wallet!</pre>
  </div>
  <div slot="connect">
    <button
      onClick={async () => {
        modals.showWalletModal(await getNetworks());
      }}
    >Connect your Wallet</button>
  </div>
</cosmos-connect-boundary>

```tsx
<cosmos-connect-boundary persist="true">
  <div slot="content">
    <pre>Thank you for connecting your wallet!</pre>
  </div>
  <div slot="connect">
    <pre>Please connect your wallet to continue.</pre>
  </div>
</cosmos-connect-boundary>
```

The component will emit the `connected` event when the user connects their
wallet. This can be used to automatically prompt the user to sign in.

## Toast

Currently, Cosmos Components use our own Toast implementation. In the future,
we will allow specifying an alternative Toast implementation for consistency
across different systems. Click the button below to spawn a new toast.

<button
  onClick={() => toast.info('This is an informational toast.')}
>Spawn toast</button>

```tsx
<button onClick={() => toast.info('This is an informational toast.')}>Spawn toast</button>
```

These web components are built on the Shadow DOM. Thus, proper integration with
your framework may be non-trivial. Most modern frameworks build on a VDOM, which
is not directly compatible with the Shadow DOM. If you need to provide content
to the Toast that is not just a simple string, you probably want to build a
helper for your framework.

### Error Link Toast
The `toast.errorlink` function is a variation of the `toast.error` method that
includes a link to open a `cosmos-modal-error` containing the error details.

<button
  onClick={() => toast.errorlink(new Error('This is a dummy error'), { message: 'Failed to connect wallet.' })}
>Spawn error link toast</button>

# TypeScript integration
Generally, web components are compatible with JSX by design, as the support only
depends on the browser, not your framework. However, TypeScript is a different
story, as TypeScript is only aware of the standard elements, not custom elements.
Your code will work even if TypeScript complains.

This library ships with TypeScript typings for React & Preact. In the future, it
may be even easier to integrate custom elements as the web standards evolve. But
until then, individual frameworks need to be integrated directly.

To integrate with React or Preact, simply import the typings:

```tsx
import '@kiruse/cosmos-components/react';
// or
import '@kiruse/cosmos-components/preact';
```

For other frameworks, you may need to define the types yourself. For this, this
library exports the `CosmosElements` interface, which you can use together with
interface merging in an ambient module declaration.

For example, create a `global.d.ts` file in your project root:

```ts
// global.d.ts
import { CosmosElements } from '@kiruse/cosmos-components';

declare module 'react/jsx-runtime' {
  namespace JSX {
    interface IntrinsicElements extends CosmosElements {}
  }
}

declare module 'preact/jsx-runtime' {
  namespace JSX {
    interface IntrinsicElements extends CosmosElements {}
  }
}
```

The above snippet is how React & Preact are actually integrated with these
components.

# Caveat about Signals
While you can pass in signals to these components, your framework may unwrap
the signal into a plain value. Preact does this, for example. Generally,
whenever a signal would be updated by these components, they will also call
a callback function, so you can pass signals in directly, but may still have
to rely on callbacks to update your signals.

However, these components currently do not feed data back out to signals.
